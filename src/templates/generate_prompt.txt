你是一位资深Pytest测试工程师。请根据测试用例文档和已提供的依赖分析/探测数据，生成可执行的Pytest测试代码。不要再次执行网络探测。

## 任务说明
根据已生成的测试用例文档和数据探测结果，生成对应的Pytest测试脚本。

## 输入文件
1. 测试用例文档: {testcases_file}
2. 探测数据文件: {output_dir}/explored_data.json
3. 依赖分析摘要: {dependency_analysis_block}
4. 探测数据摘要: {exploration_block}

**请先读取以上文件，了解可用的真实数据/依赖。不要自行探测网络。**

## Swagger定义
{swagger_content}
{requirements_content}
{data_content}

## 环境配置
- Base URL: {base_url}
- Auth Token: {auth_token}
- Timeout: {timeout}s

---

# 第一步：读取探测数据

读取 `{output_dir}/explored_data.json`，提取：
- `extracted_resources`: 可用的真实资源ID
- `field_patterns`: 字段的真实值样例
- `overall_success`: 探测是否成功

---

# 第二步：生成测试代码（仅使用已有数据，不再探测网络）

请在 {output_dir}/tests/ 目录下仅生成业务用例文件 `test_*.py`，并使用已存在的 fixture/helper：
- 已生成的文件：conftest.py / pytest.ini / requirements.txt（不要覆盖）
- 可用对象：api_client、base_url、explored_data、explored_resources、get_explored_id

## 1. test_xxx.py 测试文件规范

### 1.1 使用探测数据

```python
import pytest
from conftest import get_explored_id, EXPLORED_DATA


class TestXxxAPI:
    """Xxx接口测试"""

    # TestCase: TC-001
    @pytest.mark.p0
    def test_query_with_real_id(self, api_client, base_url):
        """正常查询-使用探测到的真实ID"""
        # 获取探测到的真实ID
        template_id = get_explored_id("templateId", default=None)

        if template_id is None:
            pytest.skip("探测未获取到有效 templateId，跳过此测试")

        response = api_client.get(f"{{base_url}}/v1/config-templates/{{template_id}}/view/basic")
        assert response.status_code == 200

        data = response.json()
        assert data.get("success") is True or "entity" in data
```

### 2.2 创建操作 + 后置验证

```python
    # TestCase: TC-010
    @pytest.mark.p0
    def test_create_with_verification(self, api_client, base_url):
        """创建模板-带后置验证"""
        import uuid

        # 参考探测到的数据格式构造测试数据
        test_data = {{
            "templateName": f"pytest_create_{{uuid.uuid4().hex[:8]}}",
            "templateType": 1,  # 使用探测到的有效枚举值
            "templateDesc": "自动化测试创建"
        }}

        # 1. 执行创建
        response = api_client.post(f"{{base_url}}/v1/config-templates", json=test_data)
        assert response.status_code == 200, f"创建失败: {{response.text}}"

        result = response.json()
        assert result.get("success") is True, f"业务失败: {{result}}"

        # 2. 提取返回的ID
        created_id = None
        entity = result.get("entity", {{}})
        if isinstance(entity, dict):
            created_id = entity.get("pkCollectTemplate") or entity.get("id") or entity.get("key")
        elif isinstance(entity, str):
            created_id = entity

        assert created_id is not None, f"创建应返回ID，实际返回: {{result}}"

        # 3. 后置验证 - 查询确认数据存在
        verify_response = api_client.get(f"{{base_url}}/v1/config-templates/{{created_id}}/view/basic")
        assert verify_response.status_code == 200, f"创建后查询失败: {{verify_response.text}}"

        verify_data = verify_response.json()
        # 验证创建的数据字段正确
        entity_data = verify_data.get("entity", {{}})
        if isinstance(entity_data, dict):
            assert entity_data.get("templateName") == test_data["templateName"], "模板名称不匹配"
```

### 2.3 更新操作 + 后置验证

```python
    # TestCase: TC-020
    @pytest.mark.p0
    def test_update_with_verification(self, api_client, base_url):
        """更新模板-带后置验证"""
        template_id = get_explored_id("templateId", default=None)

        if template_id is None:
            pytest.skip("探测未获取到有效 templateId")

        # 1. 先查询当前数据
        pre_response = api_client.get(f"{{base_url}}/v1/config-templates/{{template_id}}/view/basic")
        if pre_response.status_code != 200:
            pytest.skip(f"模板 {{template_id}} 不存在")

        original_data = pre_response.json().get("entity", {{}})

        # 2. 执行更新
        import uuid
        new_desc = f"更新测试_{{uuid.uuid4().hex[:8]}}"
        update_data = {{
            "pkCollectTemplate": template_id,
            "templateDesc": new_desc
        }}

        response = api_client.put(f"{{base_url}}/v1/config-templates", json=update_data)
        assert response.status_code == 200, f"更新失败: {{response.text}}"

        # 3. 后置验证 - 确认更新生效
        verify_response = api_client.get(f"{{base_url}}/v1/config-templates/{{template_id}}/view/basic")
        assert verify_response.status_code == 200

        updated_data = verify_response.json().get("entity", {{}})
        assert updated_data.get("templateDesc") == new_desc, "更新未生效"
```

### 2.4 删除操作 + 后置验证

```python
    # TestCase: TC-030
    @pytest.mark.p0
    def test_delete_with_verification(self, api_client, base_url):
        """删除模板-带后置验证（先创建再删除）"""
        import uuid

        # 1. 先创建一个测试数据
        create_data = {{
            "templateName": f"pytest_delete_{{uuid.uuid4().hex[:8]}}",
            "templateType": 1
        }}
        create_response = api_client.post(f"{{base_url}}/v1/config-templates", json=create_data)

        if create_response.status_code != 200:
            pytest.skip("无法创建测试数据")

        result = create_response.json()
        entity = result.get("entity", {{}})
        created_id = entity.get("pkCollectTemplate") if isinstance(entity, dict) else entity

        if not created_id:
            pytest.skip("创建未返回ID")

        # 2. 验证数据存在
        pre_check = api_client.get(f"{{base_url}}/v1/config-templates/{{created_id}}/view/basic")
        assert pre_check.status_code == 200, "删除前数据应存在"

        # 3. 执行删除
        response = api_client.delete(f"{{base_url}}/v1/config-templates/{{created_id}}")
        assert response.status_code == 200, f"删除失败: {{response.text}}"

        # 4. 后置验证 - 确认已删除
        post_check = api_client.get(f"{{base_url}}/v1/config-templates/{{created_id}}/view/basic")
        assert post_check.status_code in [404, 400, 200], "删除后查询应返回404或空数据"

        # 如果返回200，检查数据是否真的不存在
        if post_check.status_code == 200:
            data = post_check.json()
            entity = data.get("entity")
            assert entity is None or entity == {{}}, f"删除后数据仍存在: {{entity}}"
```

---

## 代码规范

1. **用例ID标记**: 每个测试函数上方必须有 `# TestCase: TC-XXX` 注释
2. **优先级标记**: 使用 `@pytest.mark.p0/p1/p2` 标记优先级
3. **函数命名**: `test_{{场景英文描述}}`
4. **类组织**: 同一API的测试放在同一个类中
5. **数据来源**:
   - 优先使用 `get_explored_id()` 获取探测数据
   - 探测失败时使用 `pytest.skip()` 跳过而非硬编码假数据
6. **后置验证**: 增删改操作必须有验证步骤确认操作生效

---

## 测试数据使用优先级

1. **探测数据** (最优先): `get_explored_id("resourceId")`
2. **Swagger example**: 当探测失败时参考
3. **合理构造**: 基于字段类型和业务含义构造

---

## 探测失败处理

如果 `explored_data.json` 显示 `overall_success: false`：

```python
def test_xxx(self, api_client, base_url, explored_data):
    if not explored_data.get("overall_success"):
        # 记录日志说明使用推断数据
        print("警告: 数据探测失败，使用推断值测试")

    # 尝试获取探测ID，失败时使用兜底值
    template_id = get_explored_id("templateId", default="fallback-id-001")
    # ... 继续测试，但预期可能失败
```

---

## 重要提醒

1. **必须先读取 explored_data.json**，了解有哪些真实数据可用
2. **增删改操作必须有后置验证**，确认操作真正生效
3. **探测失败时使用 pytest.skip()**，而不是硬编码假数据导致误报
4. **测试函数要有清晰的注释**，说明测试意图和数据来源
