你是一位资深Pytest测试工程师。请根据测试用例文档和已提供的依赖分析/探测数据，生成可执行的Pytest测试代码。不要再次执行网络探测。

## 任务说明
根据已生成的测试用例文档和数据探测结果，生成对应的Pytest测试脚本。

## 输入文件
1. 测试用例文档: {testcases_file}
2. 探测数据文件: {output_dir}/explored_data.json
3. 依赖分析摘要: {dependency_analysis_block}
4. 探测数据摘要: {exploration_block}
5. **必须实现的显式依赖**:
{explicit_dependencies_block}

⚠️ **重要**: 上述显式依赖必须在测试代码中完整实现，不能仅作为注释！

**请先读取以上文件，了解可用的真实数据/依赖。不要自行探测网络。**

## Swagger定义
{swagger_content}
{requirements_content}
{data_content}

{scenarios_block}

{rules_block}

{data_mapping_block}

{test_data_content_block}

## 环境配置
- Base URL: {base_url}
- Auth Token: {auth_token}
- Timeout: {timeout}s

---

# 第一步：读取探测数据

读取 `{output_dir}/explored_data.json`，提取：
- `extracted_resources`: 可用的真实资源ID
- `field_patterns`: 字段的真实值样例
- `overall_success`: 探测是否成功

---

# 第二步：生成测试代码（仅使用已有数据，不再探测网络）

请在 {output_dir}/tests/ 目录下仅生成业务用例文件 `test_*.py`，并使用已存在的 fixture/helper：
- 已生成的文件：conftest.py / pytest.ini / requirements.txt（不要覆盖）
- 可用对象：api_client、base_url、explored_data、explored_resources、get_explored_id

## 1. test_xxx.py 测试文件规范

### 1.1 使用探测数据

```python
import pytest
from conftest import get_explored_id, EXPLORED_DATA


class TestXxxAPI:
    """Xxx接口测试"""

    # TestCase: TC-001
    @pytest.mark.p0
    def test_query_with_real_id(self, api_client, base_url):
        """正常查询-使用探测到的真实ID"""
        # 获取探测到的真实ID
        template_id = get_explored_id("templateId", default=None)

        if template_id is None:
            pytest.skip("探测未获取到有效 templateId，跳过此测试")

        response = api_client.get(f"{{base_url}}/v1/config-templates/{{template_id}}/view/basic")
        assert response.status_code == 200

        data = response.json()
        assert data.get("success") is True or "entity" in data
```

### 2.2 创建操作 + 后置验证

```python
    # TestCase: TC-010
    @pytest.mark.p0
    def test_create_with_verification(self, api_client, base_url):
        """创建模板-带后置验证"""
        import uuid

        # 参考探测到的数据格式构造测试数据
        test_data = {{
            "templateName": f"pytest_create_{{uuid.uuid4().hex[:8]}}",
            "templateType": 1,  # 使用探测到的有效枚举值
            "templateDesc": "自动化测试创建"
        }}

        # 1. 执行创建
        response = api_client.post(f"{{base_url}}/v1/config-templates", json=test_data)
        assert response.status_code == 200, f"创建失败: {{response.text}}"

        result = response.json()
        assert result.get("success") is True, f"业务失败: {{result}}"

        # 2. 提取返回的ID
        created_id = None
        entity = result.get("entity", {{}})
        if isinstance(entity, dict):
            created_id = entity.get("pkCollectTemplate") or entity.get("id") or entity.get("key")
        elif isinstance(entity, str):
            created_id = entity

        assert created_id is not None, f"创建应返回ID，实际返回: {{result}}"

        # 3. 后置验证 - 查询确认数据存在
        verify_response = api_client.get(f"{{base_url}}/v1/config-templates/{{created_id}}/view/basic")
        assert verify_response.status_code == 200, f"创建后查询失败: {{verify_response.text}}"

        verify_data = verify_response.json()
        # 验证创建的数据字段正确
        entity_data = verify_data.get("entity", {{}})
        if isinstance(entity_data, dict):
            assert entity_data.get("templateName") == test_data["templateName"], "模板名称不匹配"
```

### 2.3 更新操作 + 后置验证

```python
    # TestCase: TC-020
    @pytest.mark.p0
    def test_update_with_verification(self, api_client, base_url):
        """更新模板-带后置验证"""
        template_id = get_explored_id("templateId", default=None)

        if template_id is None:
            pytest.skip("探测未获取到有效 templateId")

        # 1. 先查询当前数据
        pre_response = api_client.get(f"{{base_url}}/v1/config-templates/{{template_id}}/view/basic")
        if pre_response.status_code != 200:
            pytest.skip(f"模板 {{template_id}} 不存在")

        original_data = pre_response.json().get("entity", {{}})

        # 2. 执行更新
        import uuid
        new_desc = f"更新测试_{{uuid.uuid4().hex[:8]}}"
        update_data = {{
            "pkCollectTemplate": template_id,
            "templateDesc": new_desc
        }}

        response = api_client.put(f"{{base_url}}/v1/config-templates", json=update_data)
        assert response.status_code == 200, f"更新失败: {{response.text}}"

        # 3. 后置验证 - 确认更新生效
        verify_response = api_client.get(f"{{base_url}}/v1/config-templates/{{template_id}}/view/basic")
        assert verify_response.status_code == 200

        updated_data = verify_response.json().get("entity", {{}})
        assert updated_data.get("templateDesc") == new_desc, "更新未生效"
```

### 2.4 删除操作 + 后置验证

```python
    # TestCase: TC-030
    @pytest.mark.p0
    def test_delete_with_verification(self, api_client, base_url):
        """删除模板-带后置验证（先创建再删除）"""
        import uuid

        # 1. 先创建一个测试数据
        create_data = {{
            "templateName": f"pytest_delete_{{uuid.uuid4().hex[:8]}}",
            "templateType": 1
        }}
        create_response = api_client.post(f"{{base_url}}/v1/config-templates", json=create_data)

        if create_response.status_code != 200:
            pytest.skip("无法创建测试数据")

        result = create_response.json()
        entity = result.get("entity", {{}})
        created_id = entity.get("pkCollectTemplate") if isinstance(entity, dict) else entity

        if not created_id:
            pytest.skip("创建未返回ID")

        # 2. 验证数据存在
        pre_check = api_client.get(f"{{base_url}}/v1/config-templates/{{created_id}}/view/basic")
        assert pre_check.status_code == 200, "删除前数据应存在"

        # 3. 执行删除
        response = api_client.delete(f"{{base_url}}/v1/config-templates/{{created_id}}")
        assert response.status_code == 200, f"删除失败: {{response.text}}"

        # 4. 后置验证 - 确认已删除
        post_check = api_client.get(f"{{base_url}}/v1/config-templates/{{created_id}}/view/basic")
        assert post_check.status_code in [404, 400, 200], "删除后查询应返回404或空数据"

        # 如果返回200，检查数据是否真的不存在
        if post_check.status_code == 200:
            data = post_check.json()
            entity = data.get("entity")
            assert entity is None or entity == {{}}, f"删除后数据仍存在: {{entity}}"
```

---

## 业务测试生成要求（重要）

如果上方存在「业务场景」、「业务规则」或「测试数据映射」，必须生成对应的业务测试代码。

### 场景测试（端到端流程）

如果「业务场景」非空，必须为每个场景生成端到端测试：

```python
# TestCase: TC-SCENARIO-001
@pytest.mark.p0
class TestOrderFlow:
    """业务场景: 订单完整流程"""

    def test_order_flow_end_to_end(self, api_client, base_url):
        """订单流程: 创建→支付→发货→收货"""
        # Step 1: 创建订单
        order_resp = api_client.post(f"{{base_url}}/orders", json={{
            "productId": "prod-001",
            "quantity": 2
        }})
        assert order_resp.status_code == 200
        order_id = order_resp.json().get("entity", {{}}).get("orderId")
        assert order_id is not None, "订单创建应返回orderId"

        # Step 2: 支付订单
        pay_resp = api_client.post(f"{{base_url}}/orders/{{order_id}}/pay")
        assert pay_resp.status_code == 200
        assert pay_resp.json().get("entity", {{}}).get("status") == "PAID"

        # Step 3: 发货
        ship_resp = api_client.post(f"{{base_url}}/orders/{{order_id}}/ship")
        assert ship_resp.status_code == 200
        assert ship_resp.json().get("entity", {{}}).get("status") == "SHIPPED"

        # Step 4: 确认收货
        receive_resp = api_client.post(f"{{base_url}}/orders/{{order_id}}/receive")
        assert receive_resp.status_code == 200
        assert receive_resp.json().get("entity", {{}}).get("status") == "COMPLETED"
```

### 业务规则测试

如果「业务规则」非空，必须为每条规则生成验证测试：

```python
# TestCase: TC-RULE-001
@pytest.mark.p0
def test_discount_rule_100(self, api_client, base_url):
    """业务规则验证: 满100减10"""
    order_data = {{
        "items": [{{"productId": "p1", "price": 60, "quantity": 2}}],
        "subtotal": 120
    }}
    response = api_client.post(f"{{base_url}}/orders", json=order_data)
    assert response.status_code == 200

    result = response.json().get("entity", {{}})
    # 验证业务规则: 120 满100减10 = 110
    assert result.get("discount") == 10, f"期望折扣10，实际: {{result.get('discount')}}"
    assert result.get("finalAmount") == 110, f"期望最终金额110，实际: {{result.get('finalAmount')}}"
```

### 数据驱动测试

⚠️ **强制要求**: 如果上方存在「用户上传的测试数据内容」，必须：
1. 将上传的 JSON 数据复制为 Python 列表常量
2. 使用 `@pytest.mark.parametrize` 进行数据驱动测试
3. 每行数据生成一个独立的测试用例
4. 测试文件命名: `test_data_*.py`

如果「测试数据映射」非空，使用 pytest 参数化从用户上传的测试数据生成测试：

```python
# ⚠️ 必须从上方「用户上传的测试数据内容」中复制实际数据
# 示例：假设上传了检查项数据
TEST_DATA_CHECKITEMS = [
    {{"检查项ID": "186242eecb1f45ddaabed189244f287e", "检查项名称": "检查是否为Oozie开启kerberos认证", "是否必选": "否"}},
    {{"检查项ID": "2255dc61a9ea453888fdddcffed26ffe", "检查项名称": "4.1.2.3 检查口令重复次数限制", "是否必选": "是"}},
    # ... 必须包含所有上传的数据行
]

# TestCase: TC-DATA-001
@pytest.mark.p0
@pytest.mark.parametrize("row", TEST_DATA_CHECKITEMS)
def test_add_checkitem_data_driven(self, api_client, base_url, row):
    """数据驱动测试: 添加检查项 - 使用上传的测试数据"""
    # 从数据行中提取字段
    checkitem_id = row.get("检查项ID")
    is_required = row.get("是否必选") == "是"

    response = api_client.patch(
        f"{{base_url}}/v3/config-templates/selectTemplate/{{template_id}}",
        json={{"pkAssets": [checkitem_id]}}
    )

    # 根据数据中的预期结果进行断言
    if is_required:
        assert response.status_code == 200, f"必选检查项 {{checkitem_id}} 添加失败"
    else:
        # 非必选项可能有不同的业务逻辑
        assert response.status_code in [200, 400]
```

**关键点**:
- `TEST_DATA_XXX` 列表必须包含上传数据中的**所有行**
- 列名必须与上传数据的列名**完全一致**（包括中文）
- 如果数据中有"预期结果"或"期望状态码"列，必须用于断言

**文件命名规范**:
- 场景测试文件命名: `test_scenario_*.py`
- 规则测试文件命名: `test_rule_*.py`
- 数据驱动测试文件命名: `test_data_*.py`

---

## 代码规范

1. **用例ID标记**: 每个测试函数上方必须有 `# TestCase: TC-XXX` 注释
2. **优先级标记**: 使用 `@pytest.mark.p0/p1/p2` 标记优先级
3. **函数命名**: `test_{{场景英文描述}}`
4. **类组织**: 同一API的测试放在同一个类中
5. **数据来源**:
   - 优先使用 `get_explored_id()` 获取探测数据
   - 探测失败时使用 `pytest.skip()` 跳过而非硬编码假数据
6. **后置验证**: 增删改操作必须有验证步骤确认操作生效
7. **显式依赖处理**: 如果依赖分析中有"置信度: 最高"的显式依赖，测试代码必须按依赖顺序执行前置操作

---

## 显式依赖的测试代码生成（强制执行）

⚠️ **重要**: 以下不是可选建议，而是必须执行的规则。

### 第一步：识别显式依赖

从上方「必须实现的显式依赖」部分识别所有 **置信度=最高** 或 **置信度=高** 的依赖关系。

### 第二步：实现前置调用（必须）

对于每个显式依赖，测试代码中**必须包含实际的前置接口调用代码**，而不仅仅是注释说明。

**❌ 禁止行为 - 只有注释没有实现**:
```python
# 错误示例：只写注释，没有实际调用前置接口
def test_create_template(self, api_client, base_url):
    """显式依赖: PATCH /selectTemplate/{{templateId}}"""
    # 依赖链: 1.获取检查项 2.添加检查项 3.创建模板
    template_id = str(uuid.uuid4())
    # ❌ 直接创建，跳过了前置调用！这是错误的！
    response = api_client.post(f"{{base_url}}/v3/config-templates", json=data)
```

**✅ 必须行为 - 完整实现前置调用**:
```python
# 正确示例：完整实现所有前置接口调用
def test_create_template(self, api_client, base_url):
    """创建模板 - 需要先添加检查项（显式依赖）"""
    import uuid

    # Step 1: 调用前置接口 - 获取可选检查项
    choose_resp = api_client.get(
        f"{{base_url}}/v3/config-templates/choose",
        params={{"page": 1, "perPage": 10}}
    )
    if choose_resp.status_code != 200:
        pytest.skip("前置依赖失败: 无法获取检查项列表")

    items = choose_resp.json().get("data", [])
    if not items:
        pytest.skip("前置依赖失败: 没有可用检查项")

    item_ids = [item.get("pkAssets") for item in items[:3] if item.get("pkAssets")]

    # Step 2: 调用前置接口 - 添加检查项到模板
    template_id = str(uuid.uuid4())
    select_resp = api_client.patch(
        f"{{base_url}}/v3/config-templates/selectTemplate/{{template_id}}",
        json={{"pkAssets": item_ids}}
    )
    if select_resp.status_code != 200:
        pytest.skip("前置依赖失败: 添加检查项失败")

    # Step 3: 现在执行目标操作 - 创建模板
    create_data = {{
        "pkCollectTemplate": template_id,
        "templateName": f"pytest_{{uuid.uuid4().hex[:8]}}",
        "templateType": 1
    }}
    response = api_client.post(f"{{base_url}}/v3/config-templates", json=create_data)

    assert response.status_code == 200
```

### 第三步：实现检查清单

生成代码时，对每个显式依赖必须满足以下检查项：

| 检查项 | 说明 |
|--------|------|
| ✅ 前置接口调用 | 必须有 `api_client.get/post/patch` 调用代码 |
| ✅ 响应状态检查 | 必须检查前置接口返回状态码 |
| ✅ 数据提取 | 必须从响应中提取所需的 ID 或值 |
| ✅ 失败处理 | 前置失败时使用 `pytest.skip()` 而非继续 |
| ❌ 禁止跳过 | 不允许"可选"跳过前置调用 |
| ❌ 禁止只写注释 | 注释中的依赖说明必须有对应代码实现 |

---

## 通用依赖处理示例

**示例**: `POST /items` 显式依赖 `POST /collections → collectionId`

```python
# TestCase: TC-050
@pytest.mark.p0
def test_create_item_with_collection(self, api_client, base_url):
    """创建物品 - 需要先创建集合（显式依赖）"""
    import uuid

    # Step 1: 先创建集合（前置依赖）
    collection_data = {{
        "collectionName": f"pytest_collection_{{uuid.uuid4().hex[:8]}}"
    }}
    collection_resp = api_client.post(f"{{base_url}}/v1/collections", json=collection_data)

    if collection_resp.status_code != 200:
        pytest.skip("前置依赖失败: 集合创建失败")

    # Step 2: 提取 collectionId
    collection_id = collection_resp.json().get("entity", {{}}).get("collectionId")
    if not collection_id:
        pytest.skip("前置依赖失败: 集合创建未返回 collectionId")

    # Step 3: 使用 collectionId 创建物品
    item_data = {{
        "itemName": f"pytest_item_{{uuid.uuid4().hex[:8]}}",
        "collectionId": collection_id  # 使用前置接口返回的ID
    }}
    response = api_client.post(f"{{base_url}}/v1/items", json=item_data)

    assert response.status_code == 200, f"创建物品失败: {{response.text}}"

    # Step 4: 后置验证
    item_id = response.json().get("entity", {{}}).get("itemId")
    verify_resp = api_client.get(f"{{base_url}}/v1/items/{{item_id}}")
    assert verify_resp.status_code == 200
    assert verify_resp.json().get("entity", {{}}).get("collectionId") == collection_id
```

---

## 测试数据使用优先级

1. **显式依赖的前置接口返回值** (最优先): 通过调用前置接口获取
2. **探测数据**: `get_explored_id("resourceId")`
3. **Swagger example**: 当探测失败时参考
4. **合理构造**: 基于字段类型和业务含义构造

---

## 探测失败处理

如果 `explored_data.json` 显示 `overall_success: false`：

```python
def test_xxx(self, api_client, base_url, explored_data):
    if not explored_data.get("overall_success"):
        # 记录日志说明使用推断数据
        print("警告: 数据探测失败，使用推断值测试")

    # 尝试获取探测ID，失败时使用兜底值
    template_id = get_explored_id("templateId", default="fallback-id-001")
    # ... 继续测试，但预期可能失败
```

---

## 重要提醒

1. **必须先读取 explored_data.json**，了解有哪些真实数据可用
2. **增删改操作必须有后置验证**，确认操作真正生效
3. **探测失败时使用 pytest.skip()**，而不是硬编码假数据导致误报
4. **测试函数要有清晰的注释**，说明测试意图和数据来源
