"""
CLIAdapter 验证测试脚本

验证 Claude Code CLI 的各种调用模式和能力。

Usage:
    python test_cli_adapter.py [--test-name TEST_NAME]

Examples:
    python test_cli_adapter.py                    # 运行所有测试
    python test_cli_adapter.py --test-name basic  # 只运行基础测试
"""

import argparse
import sys
import os
import json
import tempfile
from pathlib import Path
from datetime import datetime

# 添加当前目录到 path
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from cli_adapter import (
    create_claude_adapter,
    ClaudeCodeAdapter,
    ClaudeSession,
    CLIConfig,
    CLIType,
    ExecutionMode,
    CLIResult
)


class TestResult:
    """测试结果记录"""

    def __init__(self, name: str):
        self.name = name
        self.passed = False
        self.message = ""
        self.details: dict = {}
        self.duration: float = 0.0

    def __str__(self):
        status = "✅ PASS" if self.passed else "❌ FAIL"
        return f"{status} | {self.name} ({self.duration:.2f}s) - {self.message}"


class CLIAdapterTester:
    """CLI 适配器测试器"""

    def __init__(self, working_dir: str = None):
        self.working_dir = working_dir or tempfile.mkdtemp(prefix="cli_test_")
        self.results: list[TestResult] = []
        self.adapter: ClaudeCodeAdapter = None

    def setup(self) -> bool:
        """测试前准备"""
        print("\n" + "=" * 60)
        print("CLIAdapter PoC 验证测试")
        print("=" * 60)
        print(f"工作目录: {self.working_dir}")
        print(f"开始时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print("-" * 60)

        try:
            self.adapter = create_claude_adapter(
                timeout=120,
                working_dir=self.working_dir
            )
            print("✅ Adapter 初始化成功")
            return True
        except Exception as e:
            print(f"❌ Adapter 初始化失败: {e}")
            return False

    def run_test(self, test_func) -> TestResult:
        """运行单个测试"""
        result = TestResult(test_func.__name__)
        start_time = datetime.now()

        try:
            test_func(result)
        except Exception as e:
            result.passed = False
            result.message = f"Exception: {str(e)}"

        result.duration = (datetime.now() - start_time).total_seconds()
        self.results.append(result)
        print(result)
        return result

    # ==================== 测试用例 ====================

    def test_01_basic_echo(self, result: TestResult):
        """测试1: 基础命令 - 简单 echo"""
        cli_result = self.adapter.execute(
            "请直接输出文字: Hello Nexus Agent"
        )

        result.passed = cli_result.success
        result.message = f"exit_code={cli_result.exit_code}"
        result.details = {
            "output_length": len(cli_result.output or ""),
            "execution_time": cli_result.execution_time
        }

    def test_02_file_read(self, result: TestResult):
        """测试2: 文件读取能力"""
        # 先创建测试文件
        test_file = Path(self.working_dir) / "test_input.txt"
        test_file.write_text("这是测试内容\n用于验证文件读取能力")

        cli_result = self.adapter.execute(
            f"请读取文件 {test_file} 并告诉我文件内容"
        )

        result.passed = cli_result.success and "测试内容" in (cli_result.output or "")
        result.message = "文件读取成功" if result.passed else "文件读取失败或内容不匹配"
        result.details = {"file": str(test_file)}

    def test_03_file_write(self, result: TestResult):
        """测试3: 文件写入能力"""
        output_file = Path(self.working_dir) / "test_output.txt"

        cli_result = self.adapter.execute(
            f"请在 {output_file} 文件中写入内容: 'Generated by Claude Code CLI'"
        )

        # 验证文件是否被创建
        file_exists = output_file.exists()
        content_correct = False
        if file_exists:
            content = output_file.read_text()
            content_correct = "Generated" in content or "Claude" in content

        result.passed = cli_result.success and file_exists
        result.message = f"文件存在={file_exists}, 内容正确={content_correct}"
        result.details = {
            "file": str(output_file),
            "exists": file_exists
        }

    def test_04_code_generation(self, result: TestResult):
        """测试4: 代码生成能力"""
        output_file = Path(self.working_dir) / "generated_test.py"

        prompt = f"""
请在 {output_file} 生成一个简单的 Python 函数:
- 函数名: add_numbers
- 功能: 接收两个数字参数，返回它们的和
- 包含类型提示和 docstring
"""

        cli_result = self.adapter.execute(prompt)

        # 验证生成的代码
        file_exists = output_file.exists()
        has_function = False
        if file_exists:
            content = output_file.read_text()
            has_function = "def add_numbers" in content

        result.passed = cli_result.success and file_exists and has_function
        result.message = f"文件存在={file_exists}, 函数存在={has_function}"
        result.details = {
            "file": str(output_file),
            "generation_time": cli_result.execution_time
        }

    def test_05_bash_execution(self, result: TestResult):
        """测试5: Bash 命令执行能力"""
        cli_result = self.adapter.execute(
            f"请在 {self.working_dir} 目录下执行 'ls -la' 命令，并告诉我有哪些文件"
        )

        result.passed = cli_result.success
        result.message = f"执行时间={cli_result.execution_time:.2f}s"
        result.details = {
            "output_preview": (cli_result.output or "")[:200]
        }

    def test_06_error_handling(self, result: TestResult):
        """测试6: 错误处理能力"""
        # 尝试读取不存在的文件
        cli_result = self.adapter.execute(
            "请读取文件 /nonexistent/path/file.txt 并告诉我结果"
        )

        # 这个测试期望 CLI 能够优雅处理错误
        result.passed = True  # 只要不崩溃就算通过
        result.message = f"错误处理正常, success={cli_result.success}"
        result.details = {
            "handled_gracefully": True,
            "exit_code": cli_result.exit_code
        }

    def test_07_session_management(self, result: TestResult):
        """测试7: 会话管理能力"""
        session = ClaudeSession(self.adapter)

        # 启动会话
        result1 = session.start("请记住这个数字: 42")

        # 继续会话
        result2 = session.continue_session("我之前让你记住的数字是多少?")

        # 结束会话
        session.end()

        history = session.get_history()

        result.passed = result1.success and len(history) >= 1
        result.message = f"会话轮次={len(history)}"
        result.details = {
            "history_length": len(history),
            "session_active": session.is_active
        }

    def test_08_pytest_generation(self, result: TestResult):
        """测试8: Pytest 测试用例生成（核心能力验证）"""
        # 创建一个简单的被测函数
        target_file = Path(self.working_dir) / "calculator.py"
        target_file.write_text("""
def add(a: int, b: int) -> int:
    \"\"\"两数相加\"\"\"
    return a + b

def divide(a: int, b: int) -> float:
    \"\"\"除法运算\"\"\"
    if b == 0:
        raise ValueError("除数不能为零")
    return a / b
""")

        test_file = Path(self.working_dir) / "test_calculator.py"

        prompt = f"""
请为 {target_file} 中的函数生成 Pytest 测试用例，保存到 {test_file}:
1. 为 add 函数编写正常情况的测试
2. 为 divide 函数编写正常情况和除零异常的测试
3. 使用 pytest 的断言语法
"""

        cli_result = self.adapter.execute(prompt)

        # 验证
        file_exists = test_file.exists()
        has_test = False
        if file_exists:
            content = test_file.read_text()
            has_test = "def test_" in content and "assert" in content

        result.passed = cli_result.success and file_exists and has_test
        result.message = f"测试文件生成={'成功' if has_test else '失败'}"
        result.details = {
            "test_file": str(test_file),
            "has_test_functions": has_test,
            "generation_time": cli_result.execution_time
        }

    def test_09_retry_mechanism(self, result: TestResult):
        """测试9: 重试机制"""
        # 测试带重试的执行
        cli_result = self.adapter.execute_with_retry(
            "请输出: Retry test successful"
        )

        result.passed = cli_result.success
        result.message = f"重试机制正常工作"
        result.details = {
            "execution_time": cli_result.execution_time
        }

    def test_10_complex_prompt(self, result: TestResult):
        """测试10: 复杂 Prompt 处理"""
        swagger_snippet = """
{
  "paths": {
    "/users": {
      "get": {
        "summary": "获取用户列表",
        "responses": {"200": {"description": "成功"}}
      }
    }
  }
}
"""
        prompt = f"""
基于以下 Swagger 定义，生成测试场景描述（不需要生成代码，只描述测试点）:

{swagger_snippet}

请列出:
1. 正常流程测试点
2. 边界条件测试点
3. 异常流程测试点
"""

        cli_result = self.adapter.execute(prompt)

        result.passed = cli_result.success
        result.message = f"复杂Prompt处理完成"
        result.details = {
            "output_length": len(cli_result.output or ""),
            "execution_time": cli_result.execution_time
        }

    # ==================== 测试运行 ====================

    def run_all(self) -> dict:
        """运行所有测试"""
        if not self.setup():
            return {"success": False, "error": "Setup failed"}

        tests = [
            self.test_01_basic_echo,
            self.test_02_file_read,
            self.test_03_file_write,
            self.test_04_code_generation,
            self.test_05_bash_execution,
            self.test_06_error_handling,
            self.test_07_session_management,
            self.test_08_pytest_generation,
            self.test_09_retry_mechanism,
            self.test_10_complex_prompt,
        ]

        print("\n开始执行测试...\n")

        for test in tests:
            self.run_test(test)

        return self.summary()

    def run_single(self, test_name: str) -> dict:
        """运行单个测试"""
        if not self.setup():
            return {"success": False, "error": "Setup failed"}

        test_map = {
            "basic": self.test_01_basic_echo,
            "read": self.test_02_file_read,
            "write": self.test_03_file_write,
            "codegen": self.test_04_code_generation,
            "bash": self.test_05_bash_execution,
            "error": self.test_06_error_handling,
            "session": self.test_07_session_management,
            "pytest": self.test_08_pytest_generation,
            "retry": self.test_09_retry_mechanism,
            "complex": self.test_10_complex_prompt,
        }

        if test_name not in test_map:
            print(f"未知测试: {test_name}")
            print(f"可用测试: {', '.join(test_map.keys())}")
            return {"success": False, "error": "Unknown test"}

        print(f"\n运行测试: {test_name}\n")
        self.run_test(test_map[test_name])
        return self.summary()

    def summary(self) -> dict:
        """输出测试摘要"""
        print("\n" + "=" * 60)
        print("测试摘要")
        print("=" * 60)

        total = len(self.results)
        passed = sum(1 for r in self.results if r.passed)
        failed = total - passed

        print(f"总计: {total} | 通过: {passed} | 失败: {failed}")
        print(f"通过率: {passed/total*100:.1f}%" if total > 0 else "N/A")

        if failed > 0:
            print("\n失败的测试:")
            for r in self.results:
                if not r.passed:
                    print(f"  - {r.name}: {r.message}")

        print("=" * 60)

        return {
            "success": failed == 0,
            "total": total,
            "passed": passed,
            "failed": failed,
            "results": [
                {
                    "name": r.name,
                    "passed": r.passed,
                    "message": r.message,
                    "duration": r.duration
                }
                for r in self.results
            ]
        }


def main():
    parser = argparse.ArgumentParser(description="CLIAdapter PoC 验证测试")
    parser.add_argument(
        "--test-name",
        type=str,
        help="运行指定测试 (basic/read/write/codegen/bash/error/session/pytest/retry/complex)"
    )
    parser.add_argument(
        "--working-dir",
        type=str,
        help="指定工作目录"
    )
    parser.add_argument(
        "--output",
        type=str,
        help="输出结果到 JSON 文件"
    )

    args = parser.parse_args()

    tester = CLIAdapterTester(working_dir=args.working_dir)

    if args.test_name:
        summary = tester.run_single(args.test_name)
    else:
        summary = tester.run_all()

    if args.output:
        with open(args.output, "w") as f:
            json.dump(summary, f, indent=2, ensure_ascii=False)
        print(f"\n结果已保存到: {args.output}")

    sys.exit(0 if summary.get("success") else 1)


if __name__ == "__main__":
    main()
