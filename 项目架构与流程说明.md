# Smart Dev Mantis 项目架构与流程说明

> 基于 Claude Code CLI 的 AI 驱动接口自动化测试平台

---

## 一、项目概述

### 1.1 项目使命

将传统的 **"人工编写 → 人工执行 → 人工分析 → 人工修复"** 测试模式，转变为 **"人工输入 → AI生成 → AI执行 → AI自愈"** 的智能化模式。

### 1.2 核心特性

| 特性 | 说明 |
|------|------|
| **LLM 驱动** | 利用 Claude Code CLI 进行代码生成和自愈 |
| **四阶段流程** | 规划 → 生成 → 执行+自愈 → 交付 |
| **智能自愈** | 语法自愈 + 逻辑自愈双机制 |
| **依赖分析** | 静态分析 + 动态探测，优化测试执行顺序 |
| **双模式支持** | 完整模式（带业务规则）/ 轻量模式（仅 Swagger） |

### 1.3 技术栈

| 层级 | 技术 | 说明 |
|------|------|------|
| 表现层 | Flask + Flask-SocketIO | Web UI、实时推送 |
| 编排层 | Python 3.x | WorkflowEngine 四阶段编排 |
| 执行层 | Claude Code CLI | 代码生成、自愈、文件操作 |
| 测试层 | Pytest + Requests | 测试框架、HTTP 客户端 |
| 数据层 | Pydantic + dataclass | 模型定义、数据验证 |
| 报告层 | HTML + JSON | 业务报告、Bug 清单 |

---

## 二、目录结构

```
Smart-Dev-Mantis/
├── src/                              # 核心源代码
│   ├── main.py                       # CLI 入口点
│   ├── __init__.py
│   │
│   ├── core/                         # 核心编排层
│   │   ├── __init__.py               # 导出公共接口
│   │   ├── workflow_engine.py        # 工作流引擎（四阶段编排）
│   │   ├── input_parser.py           # 输入解析器
│   │   ├── prompt_builder.py         # Prompt 构建器
│   │   ├── cli_adapter.py            # Claude Code CLI 适配器
│   │   ├── cli_session.py            # CLI 会话管理
│   │   ├── pytest_runner.py          # Pytest 执行器
│   │   ├── result_judge.py           # 结果仲裁器
│   │   ├── dependency_analyzer.py    # 静态依赖分析
│   │   ├── dependency_explorer.py    # 动态依赖探测
│   │   ├── skeleton_writer.py        # 测试骨架生成
│   │   ├── testcase_parser.py        # 测试用例解析
│   │   └── report_generator.py       # 业务报告生成
│   │
│   ├── models/                       # 数据模型
│   │   ├── __init__.py
│   │   ├── context.py                # TaskContext（任务上下文）
│   │   ├── result.py                 # 执行结果模型
│   │   ├── report.py                 # 报告模型
│   │   └── dependency.py             # 依赖分析模型
│   │
│   ├── templates/                    # LLM Prompt 模板
│   │   ├── plan_prompt.txt           # 规划阶段 Prompt
│   │   ├── generate_prompt.txt       # 生成阶段 Prompt
│   │   ├── heal_syntax_prompt.txt    # 语法自愈 Prompt
│   │   ├── heal_logic_prompt.txt     # 逻辑自愈 Prompt
│   │   └── finalize_prompt.txt       # 交付阶段 Prompt
│   │
│   ├── web/                          # Web UI 层
│   │   ├── app.py                    # Flask 应用
│   │   ├── templates/
│   │   │   └── index.html            # Web 前端
│   │   └── static/                   # 静态资源
│   │
│   └── utils/                        # 工具函数
│       └── __init__.py
│
├── output/                           # 执行输出（按时间戳分目录）
├── docs/                             # 项目文档
├── poc/                              # 概念验证代码
├── test_data/                        # 测试数据
├── requirements.txt                  # Python 依赖
├── run_web.py                        # Web 服务启动脚本
└── .gitignore
```

---

## 三、核心四阶段工作流

### 3.1 整体流程图

```
┌─────────────────────────────────────────────────────────────────────┐
│                           用户输入                                   │
│      Swagger 文件 + 业务规则(可选) + 测试数据(可选) + 环境配置        │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
                          ┌─────────────────┐
                          │  InputParser    │
                          │   解析输入       │
                          └────────┬────────┘
                                   │
                                   ▼
                          ┌─────────────────┐
                          │  TaskContext    │
                          │   任务上下文     │
                          └────────┬────────┘
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────────────────┐
│                      WorkflowEngine.run()                           │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │  Phase 1: 规划 (PLANNING)                                     │  │
│  │  ┌─────────────────────────────────────────────────────────┐  │  │
│  │  │ 1. DependencyAnalyzer.analyze()   → 静态依赖分析        │  │  │
│  │  │ 2. [可选] DependencyExplorer.explore() → 动态探测       │  │  │
│  │  │ 3. PromptBuilder.build_plan_prompt()                    │  │  │
│  │  │ 4. CLISession.start(prompt)       → 调用 Claude CLI     │  │  │
│  │  └─────────────────────────────────────────────────────────┘  │  │
│  │  输出: testcases.md, dependency_analysis.json                 │  │
│  └───────────────────────────────────────────────────────────────┘  │
│                                    │                                │
│                                    ▼                                │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │  Phase 2: 生成 (GENERATING)                                   │  │
│  │  ┌─────────────────────────────────────────────────────────┐  │  │
│  │  │ 1. SkeletonWriter.write()         → 写入 conftest.py    │  │  │
│  │  │ 2. PromptBuilder.build_generate_prompt()                │  │  │
│  │  │ 3. CLISession.send(prompt)        → 生成测试代码        │  │  │
│  │  └─────────────────────────────────────────────────────────┘  │  │
│  │  输出: tests/test_*.py, conftest.py, pytest.ini               │  │
│  └───────────────────────────────────────────────────────────────┘  │
│                                    │                                │
│                                    ▼                                │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │  Phase 3: 执行 + 自愈 (EXECUTING + HEALING)                   │  │
│  │  ┌─────────────────────────────────────────────────────────┐  │  │
│  │  │ 1. TestCaseParser.parse()         → 解析用例映射        │  │  │
│  │  │ 2. PytestRunner.run()             → 执行 pytest         │  │  │
│  │  │ 3. 对每个失败用例:                                       │  │  │
│  │  │    └─ ResultJudge.judge()         → 仲裁结果            │  │  │
│  │  │       ├─ 语法错误 → _heal_syntax() → CLI 修复代码       │  │  │
│  │  │       └─ 断言失败 → _heal_logic()  → 判定 Bug/脚本问题  │  │  │
│  │  │ 4. 循环直至通过或达到最大自愈次数                        │  │  │
│  │  └─────────────────────────────────────────────────────────┘  │  │
│  │  输出: reports/report.html, results.xml                       │  │
│  └───────────────────────────────────────────────────────────────┘  │
│                                    │                                │
│                                    ▼                                │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │  Phase 4: 交付 (FINALIZING)                                   │  │
│  │  ┌─────────────────────────────────────────────────────────┐  │  │
│  │  │ 1. 统计执行结果                                          │  │  │
│  │  │ 2. _populate_test_cases()         → 关联用例设计与结果  │  │  │
│  │  │ 3. BusinessReportGenerator.generate() → 业务报告        │  │  │
│  │  │ 4. _save_bug_report()             → 保存 Bug 清单       │  │  │
│  │  └─────────────────────────────────────────────────────────┘  │  │
│  │  输出: business_report.html, bug_report.json                  │  │
│  └───────────────────────────────────────────────────────────────┘  │
│                                    │                                │
└────────────────────────────────────┼────────────────────────────────┘
                                     │
                                     ▼
                            ┌─────────────────┐
                            │  FinalReport    │
                            │   最终报告       │
                            └─────────────────┘
```

### 3.2 阶段详解

#### Phase 1: 规划阶段 (PLANNING)

**目标**：分析 Swagger 和业务规则，生成测试用例设计文档

**执行步骤**：

1. **静态依赖分析** (`DependencyAnalyzer.analyze()`)
   - 从 Swagger 提取所有端点
   - 识别资源和主键
   - 分析字段依赖关系（哪些接口需要其他接口返回的 ID）
   - 拓扑排序生成推荐执行顺序

2. **动态依赖探测** (`DependencyExplorer.explore()`, 可选)
   - 调用无路径参数的 GET 接口
   - 提取真实的 ID 数据
   - 用于测试数据准备

3. **构建规划 Prompt** (`PromptBuilder.build_plan_prompt()`)
   - 加载 `plan_prompt.txt` 模板
   - 填充 Swagger 内容、业务规则、依赖分析结果

4. **调用 Claude CLI** (`CLISession.start()`)
   - 发送 Prompt 给 Claude
   - Claude 分析并生成 `testcases.md`

**输出产物**：
- `testcases.md` - 测试用例设计文档
- `dependency_analysis.json` - 依赖分析结果

---

#### Phase 2: 生成阶段 (GENERATING)

**目标**：根据测试用例文档生成可执行的 Pytest 代码

**执行步骤**：

1. **写入测试骨架** (`SkeletonWriter.write()`)
   ```
   tests/
   ├── conftest.py      # Pytest 配置和 Fixture
   ├── pytest.ini       # Pytest 配置文件
   └── requirements.txt # 测试依赖
   ```

2. **构建生成 Prompt** (`PromptBuilder.build_generate_prompt()`)
   - 加载 `generate_prompt.txt` 模板
   - 包含 testcases.md 路径、高置信度依赖清单

3. **调用 Claude CLI** (`CLISession.send()`)
   - 继续会话，保持上下文
   - Claude 读取 testcases.md 并生成测试代码

**输出产物**：
- `tests/test_*.py` - Pytest 测试文件

---

#### Phase 3: 执行 + 自愈阶段 (EXECUTING + HEALING)

**目标**：执行测试并自动修复失败的用例

**执行步骤**：

1. **解析用例映射** (`TestCaseParser.parse()`)
   - 读取 testcases.md
   - 建立 TC-ID → 用例信息的映射

2. **执行 Pytest** (`PytestRunner.run()`)
   - 调用 `pytest` 执行测试
   - 解析 JUnit XML 获取结果

3. **处理失败用例** (循环)
   ```
   对每个失败的用例:
       │
       ├─ ResultJudge.judge()  → 分析错误类型
       │   │
       │   ├─ SYNTAX 错误 → 触发语法自愈
       │   │   └─ _heal_syntax()
       │   │       ├─ 构建 heal_syntax_prompt
       │   │       ├─ CLISession.send(prompt)
       │   │       └─ Claude 修复代码
       │   │
       │   ├─ ASSERTION 失败 → 触发逻辑自愈
       │   │   └─ _heal_logic()
       │   │       ├─ 构建 heal_logic_prompt
       │   │       ├─ CLISession.send(prompt)
       │   │       └─ Claude 判定: Bug or 脚本问题
       │   │           ├─ 是 Bug → 记录到 Bug 列表
       │   │           └─ 脚本问题 → 标记已修复
       │   │
       │   ├─ CONNECTION 错误 → 不自愈（环境问题）
       │   │
       │   └─ 超过最大自愈次数 → 不再自愈
       │
       └─ 更新用例状态
   ```

**输出产物**：
- `reports/report.html` - Pytest HTML 报告
- `reports/results.xml` - JUnit XML 报告

---

#### Phase 4: 交付阶段 (FINALIZING)

**目标**：生成业务级报告和 Bug 清单

**执行步骤**：

1. **统计执行结果**
   - 通过数、失败数、自愈成功数
   - 计算通过率

2. **关联用例设计与执行结果** (`_populate_test_cases()`)
   - 将 testcases.md 中的用例与执行结果关联
   - 填充 TestCaseDoc 列表

3. **生成业务报告** (`BusinessReportGenerator.generate()`)
   - 生成 HTML 格式的业务级报告
   - 包含通过率、用例详情、失败分析

4. **保存 Bug 报告** (`_save_bug_report()`)
   - JSON 格式的结构化 Bug 清单
   - 可集成到缺陷管理系统

**输出产物**：
- `business_report.html` - 业务级 HTML 报告
- `bug_report.json` - Bug 清单

---

## 四、核心模块详解

### 4.1 WorkflowEngine - 工作流引擎

**文件位置**：`src/core/workflow_engine.py`

**职责**：编排整个测试流程，控制四阶段状态转换

**关键类**：

```python
class WorkflowState(Enum):
    """工作流状态"""
    INIT = "初始化"
    PLANNING = "规划测试场景"
    GENERATING = "生成测试代码"
    EXECUTING = "执行测试"
    HEALING = "自愈修复中"
    FINALIZING = "生成报告"
    COMPLETED = "已完成"
    FAILED = "失败"


@dataclass
class WorkflowConfig:
    """工作流配置"""
    max_healing_attempts: int = 3       # 最大自愈次数
    cli_timeout: int = 1200             # CLI 调用超时 (20分钟)
    test_timeout: int = 120             # 单个测试用例超时
    enable_exploration: bool = False    # 是否启用依赖探测
    cancel_event: Optional[Any] = None  # 取消信号
    on_state_change: Callable           # 状态变更回调
    on_log: Callable                    # 日志回调
    on_todo_update: Callable            # Todo 更新回调
```

**核心方法**：

| 方法 | 说明 |
|------|------|
| `run()` | 执行完整工作流，返回 FinalReport |
| `_phase_planning()` | Phase 1: 规划阶段 |
| `_phase_generation()` | Phase 2: 生成阶段 |
| `_phase_execution()` | Phase 3: 执行+自愈阶段 |
| `_phase_finalization()` | Phase 4: 交付阶段 |
| `_handle_failed_test()` | 处理失败的测试用例 |
| `_heal_syntax()` | 语法自愈 |
| `_heal_logic()` | 逻辑自愈 |

---

### 4.2 CLIAdapter - CLI 适配器

**文件位置**：`src/core/cli_adapter.py`

**职责**：封装 Claude Code CLI 的调用

**调用方式**：

```bash
# 命令构建
claude -p \
  --output-format stream-json \
  --verbose \
  --dangerously-skip-permissions \
  --allowedTools Read,Write,Edit,Bash,Glob,Grep \
  [--resume sessionId]  # 会话模式
  < prompt.txt          # Prompt 通过 stdin 传递
```

**关键类**：

```python
class ExecutionMode(Enum):
    """执行模式"""
    SINGLE = "single"      # 单次调用，无状态
    SESSION = "session"    # 会话模式，保持上下文


@dataclass
class CLIConfig:
    """CLI 配置"""
    timeout: int = 1200             # 默认 20 分钟
    working_dir: Optional[str]      # 工作目录
    allowed_tools: List[str]        # 允许的工具列表
    output_format: str = "stream-json"
    max_retries: int = 3
    on_output: Callable             # 实时输出回调
    on_todo_update: Callable        # Todo 更新回调
    cancel_event: Any               # 取消信号
```

**CLISession - 会话管理**：

```python
class CLISession:
    """CLI 会话管理器 - 用于多轮交互"""

    def start(self, initial_prompt: str) -> CLIResult:
        """启动新会话"""

    def send(self, message: str) -> CLIResult:
        """发送后续消息（继续当前会话）"""

    def end(self) -> None:
        """结束会话"""
```

---

### 4.3 ResultJudge - 结果仲裁器

**文件位置**：`src/core/result_judge.py`

**职责**：分析测试结果，决定是否需要自愈以及自愈类型

**判定逻辑流程图**：

```
测试结果
    │
    ├─ status == PASS
    │   └─ 返回: 无需处理
    │
    ├─ status == TIMEOUT
    │   └─ 返回: 不自愈（超时）
    │
    ├─ status == SKIP
    │   └─ 返回: 不自愈（跳过）
    │
    ├─ healing_attempts >= max_attempts
    │   └─ 返回: 不自愈（已达上限）
    │
    ├─ error_type == SYNTAX
    │   └─ 返回: 需要语法自愈
    │       └─ HealingType.SYNTAX
    │
    ├─ error_type == CONNECTION
    │   └─ 返回: 不自愈（环境问题）
    │
    ├─ error_type == ASSERTION
    │   ├─ 完整模式 (有业务规则)
    │   │   └─ 返回: 需要逻辑自愈
    │   │       └─ HealingType.LOGIC
    │   │
    │   └─ 轻量模式 (无业务规则)
    │       └─ 返回: 不自愈，标记为 Bug
    │
    └─ 其他错误
        └─ 返回: 尝试语法自愈
```

**自愈类型**：

| 类型 | 触发条件 | 处理方式 |
|------|----------|----------|
| `SYNTAX` | SyntaxError, NameError, ImportError 等 | CLI 修复代码错误 |
| `LOGIC` | AssertionError（完整模式） | CLI 判定是 Bug 还是脚本问题 |

---

### 4.4 DependencyAnalyzer - 依赖分析器

**文件位置**：`src/core/dependency_analyzer.py`

**职责**：静态分析 Swagger，提取资源、主键、依赖关系

**分析流程**：

```
Swagger 端点列表
    │
    ├─ 1. 推断资源名
    │   └─ /api/v1/orders/{orderId} → orders
    │
    ├─ 2. 提取字段
    │   ├─ path 参数
    │   ├─ query 参数
    │   └─ requestBody 字段
    │
    ├─ 3. 识别主键
    │   └─ path 参数中的 ID 类字段 (orderId, user_id 等)
    │
    ├─ 4. 分析依赖关系
    │   └─ 字段名匹配 → 消费者-生产者关系
    │
    └─ 5. 拓扑排序
        └─ Kahn 算法，确保生产者在消费者之前
```

**HTTP 方法优先级**（同层级排序）：

```python
METHOD_PRIORITY = {
    'GET': 1,      # 查询无副作用，最先执行
    'POST': 2,     # 创建资源
    'PUT': 3,      # 更新资源
    'PATCH': 4,    # 部分更新
    'DELETE': 5,   # 删除最后执行
}
```

---

### 4.5 PromptBuilder - Prompt 构建器

**文件位置**：`src/core/prompt_builder.py`

**职责**：加载模板并填充动态变量

**工具权限管理**：

```python
# 标准工具（规划、生成阶段）
STANDARD_TOOLS = ["Read", "Write", "Edit", "Bash", "Glob", "Grep"]

# 编辑工具（自愈阶段，权限收敛）
EDIT_TOOLS = ["Read", "Edit"]
```

**Prompt 类型**：

| Prompt | 模板文件 | 用途 | 工具权限 |
|--------|----------|------|----------|
| `plan_prompt` | plan_prompt.txt | 规划测试用例 | STANDARD_TOOLS |
| `generate_prompt` | generate_prompt.txt | 生成 Pytest 代码 | STANDARD_TOOLS |
| `heal_syntax_prompt` | heal_syntax_prompt.txt | 修复语法错误 | EDIT_TOOLS |
| `heal_logic_prompt` | heal_logic_prompt.txt | 判定 Bug/脚本问题 | EDIT_TOOLS |

---

### 4.6 PytestRunner - Pytest 执行器

**文件位置**：`src/core/pytest_runner.py`

**职责**：调用 pytest 并解析执行结果

**执行命令**：

```bash
pytest tests/ \
  --junitxml=reports/results.xml \
  --html=reports/report.html \
  --self-contained-html \
  --timeout=120 \
  -v -s
```

**结果解析**：

1. 解析 JUnit XML 获取每个用例的状态
2. 从测试文件中提取 `# TestCase: TC-XXX` 注释
3. 分析错误类型（Syntax/Assertion/Connection）
4. 提取断言的期望值和实际值

---

## 五、数据模型详解

### 5.1 TaskContext - 任务上下文

**文件位置**：`src/models/context.py`

**说明**：贯穿整个工作流的数据容器

```python
@dataclass
class TaskContext:
    # 必填输入
    swagger: SwaggerSpec           # 解析后的 Swagger 规范
    config: EnvConfig              # 环境配置

    # 可选输入
    requirements: Optional[str]    # 业务规则原文
    data_assets: Optional[str]     # 业务数据原文

    # 运行时状态
    session_id: Optional[str]      # CLI Session ID
    output_dir: str                # 输出目录
    dependency_analysis: Any       # 静态依赖分析结果
    exploration_data: Any          # 动态探测数据

    # 自动计算属性
    @property
    def test_mode(self) -> TestMode:
        """根据是否有业务规则判断测试模式"""
        if self.requirements:
            return TestMode.COMPLETE  # 完整模式
        return TestMode.LIGHT         # 轻量模式
```

### 5.2 TestCaseResult - 测试结果

**文件位置**：`src/models/result.py`

```python
@dataclass
class TestCaseResult:
    testcase_id: str               # TC-001
    function_name: str             # test_create_order
    file_path: str                 # test_order_api.py
    status: TestStatus             # PASS/FAIL/ERROR/TIMEOUT/SKIP
    duration: float                # 执行时间（秒）
    error_info: Optional[ErrorInfo]
    healing_attempts: int          # 自愈尝试次数
    healed: bool                   # 是否自愈成功
```

### 5.3 ErrorInfo - 错误信息

```python
@dataclass
class ErrorInfo:
    error_type: ErrorType          # SYNTAX/ASSERTION/CONNECTION/TIMEOUT/UNKNOWN
    file: str                      # 文件名
    function: str                  # 函数名
    testcase_id: Optional[str]
    line: Optional[int]            # 行号
    message: str                   # 错误消息
    traceback: str                 # 完整 traceback
    # 断言失败时的额外信息
    assertion: Optional[str]       # 断言表达式
    expected: Optional[str]        # 期望值
    actual: Optional[str]          # 实际值
    response_body: Optional[Dict]  # API 响应体
```

### 5.4 FinalReport - 最终报告

**文件位置**：`src/models/report.py`

```python
@dataclass
class FinalReport:
    # 基本信息
    project_name: str
    generated_at: str
    execution_time: str

    # 统计数据
    total_cases: int               # 总用例数
    passed: int                    # 通过数
    failed: int                    # 失败数
    bugs_found: int                # 发现的 Bug 数
    healed_count: int              # 自愈成功次数
    total_duration: float          # 总执行时间

    # 详细数据
    test_cases: List[TestCaseDoc]      # 用例文档
    test_results: List[TestCaseResult] # 执行结果
    bugs: List[BugReport]              # Bug 清单

    # 输出文件路径
    output_dir: str
    testcases_file: str            # testcases.md
    report_html: str               # report.html
    report_xml: str                # results.xml
    bug_report_file: str           # bug_report.json
    business_report: str           # business_report.html

    @property
    def pass_rate(self) -> float:
        """通过率"""
        return self.passed / self.total_cases * 100 if self.total_cases else 0
```

---

## 六、输出目录结构

每次执行会生成一个带时间戳的输出目录：

```
output/2025-11-30_143052/
│
├── testcases.md                   # 测试用例设计文档
│   │
│   │  格式示例:
│   │  ┌────────────────────────────────────────────────────┐
│   │  │ # API 测试用例文档                                 │
│   │  │                                                    │
│   │  │ ## 一、概述                                        │
│   │  │ - API标题: xxx                                     │
│   │  │ - 版本: v1                                         │
│   │  │                                                    │
│   │  │ ## 二、依赖关系分析                                │
│   │  │ - POST /orders → GET /orders/{id}                  │
│   │  │                                                    │
│   │  │ ## 三、测试用例详情                                │
│   │  │                                                    │
│   │  │ ### API-01: POST /api/v1/orders                    │
│   │  │ | TC-ID  | 场景     | 优先级 | 测试数据 | 预期结果 │
│   │  │ |--------|----------|--------|---------|---------|│
│   │  │ | TC-001 | 正常创建 | P0     | {...}   | 201     │
│   │  │ | TC-002 | 缺少必填 | P1     | {...}   | 400     │
│   │  └────────────────────────────────────────────────────┘
│
├── tests/                         # Pytest 测试代码
│   ├── conftest.py                # Fixture 和配置
│   │   │
│   │   │  包含:
│   │   │  - BASE_URL, AUTH_TOKEN 常量
│   │   │  - api_client (requests.Session) fixture
│   │   │  - explored_resources (探测数据) fixture
│   │   │  - get_explored_id() 工具函数
│   │   │
│   ├── pytest.ini                 # Pytest 配置
│   ├── requirements.txt           # 测试依赖
│   ├── test_api_01_orders.py      # 订单相关测试
│   ├── test_api_02_users.py       # 用户相关测试
│   └── ...
│
├── reports/                       # 执行报告
│   ├── report.html                # Pytest HTML 报告
│   ├── results.xml                # JUnit XML 报告
│   └── business_report.html       # 业务级 HTML 报告
│
├── dependency_analysis.json       # 静态依赖分析结果
│   │
│   │  格式示例:
│   │  {
│   │    "resources": {
│   │      "orders": {
│   │        "primary_keys": ["orderId"],
│   │        "endpoints": [...]
│   │      }
│   │    },
│   │    "dependencies": [...],
│   │    "sorted_endpoints": [...]
│   │  }
│   │
│
├── explored_data.json             # 动态探测提取的数据（可选）
│   │
│   │  格式示例:
│   │  {
│   │    "extracted_resources": {
│   │      "orders": ["order-001", "order-002"],
│   │      "users": ["user-001"]
│   │    }
│   │  }
│   │
│
├── exploration_log.json           # 探测过程日志（可选）
│
└── bug_report.json                # Bug 清单
    │
    │  格式示例:
    │  {
    │    "summary": {
    │      "total": 2,
    │      "high": 1,
    │      "medium": 1,
    │      "low": 0
    │    },
    │    "bugs": [
    │      {
    │        "testcase_id": "TC-005",
    │        "api": "POST /api/v1/orders",
    │        "scenario": "创建重复订单",
    │        "expected": "400, 返回错误提示",
    │        "actual": "200, 创建成功",
    │        "severity": "high",
    │        "root_cause": "后端未校验订单唯一性"
    │      }
    │    ]
    │  }
```

---

## 七、使用方式

### 7.1 CLI 模式

```bash
# 轻量模式（仅 Swagger）
python -m src.main \
  --swagger api.json \
  --base-url https://api.example.com

# 完整模式（带业务规则）
python -m src.main \
  --swagger api.json \
  --base-url https://api.example.com \
  --requirements rules.md \
  --data data.md \
  --token "Bearer eyJ..."

# 指定输出目录和参数
python -m src.main \
  --swagger api.json \
  --base-url https://api.example.com \
  --output ./my_output \
  --timeout 180 \
  --max-healing 5 \
  --verbose
```

**参数说明**：

| 参数 | 简写 | 必填 | 说明 |
|------|------|------|------|
| `--swagger` | `-s` | 是 | Swagger/OpenAPI 文件路径 |
| `--base-url` | `-u` | 是 | API 基础 URL |
| `--requirements` | `-r` | 否 | 业务规则文件（Markdown） |
| `--data` | `-d` | 否 | 测试数据文件（Markdown） |
| `--token` | `-t` | 否 | 认证 Token |
| `--output` | `-o` | 否 | 输出目录，默认 `./output` |
| `--timeout` | | 否 | 单个用例超时（秒），默认 120 |
| `--max-healing` | | 否 | 最大自愈次数，默认 3 |
| `--verbose` | `-v` | 否 | 详细输出 |

### 7.2 Web UI 模式

```bash
# 启动 Web 服务
python run_web.py

# 指定端口
python run_web.py --port 8080

# 调试模式
python run_web.py --debug
```

访问 `http://localhost:5000` 使用 Web UI。

---

## 八、关键调用链

### 8.1 完整工作流调用链

```
main()
  │
  ├─ InputParser.parse()
  │   ├─ 解析 Swagger (JSON/YAML)
  │   ├─ 读取业务规则文件
  │   ├─ 读取测试数据文件
  │   └─ 构建 TaskContext
  │
  └─ WorkflowEngine(context, config)
      │
      └─ run()
          │
          ├─ _phase_planning()
          │   ├─ DependencyAnalyzer.analyze()
          │   │   ├─ _infer_resource_name()
          │   │   ├─ _extract_fields()
          │   │   ├─ _find_producers()
          │   │   └─ _topological_sort()
          │   │
          │   ├─ [可选] DependencyExplorer.explore()
          │   │
          │   ├─ PromptBuilder.build_plan_prompt()
          │   │   └─ 加载 plan_prompt.txt + 填充变量
          │   │
          │   └─ CLISession.start(prompt)
          │       └─ CLIAdapter.execute()
          │           └─ subprocess: claude -p ...
          │
          ├─ _phase_generation()
          │   ├─ SkeletonWriter.write()
          │   │   ├─ write_conftest_py()
          │   │   ├─ write_pytest_ini()
          │   │   └─ write_requirements_txt()
          │   │
          │   ├─ PromptBuilder.build_generate_prompt()
          │   │
          │   └─ CLISession.send(prompt)
          │       └─ CLIAdapter.execute(mode=SESSION)
          │
          ├─ _phase_execution()
          │   ├─ TestCaseParser.parse()
          │   │   └─ 建立 TC-ID → 用例映射
          │   │
          │   ├─ PytestRunner.run()
          │   │   ├─ subprocess: pytest ...
          │   │   └─ _parse_junit_xml()
          │   │
          │   └─ 对每个失败用例:
          │       └─ _handle_failed_test()
          │           ├─ ResultJudge.judge()
          │           │
          │           ├─ [语法自愈] _heal_syntax()
          │           │   ├─ PromptBuilder.build_heal_syntax_prompt()
          │           │   └─ CLISession.send(prompt)
          │           │
          │           └─ [逻辑自愈] _heal_logic()
          │               ├─ PromptBuilder.build_heal_logic_prompt()
          │               ├─ CLISession.send(prompt)
          │               └─ _parse_logic_healing_result()
          │                   ├─ Bug → _record_bug()
          │                   └─ 脚本问题 → 标记已修复
          │
          └─ _phase_finalization()
              ├─ 统计结果
              ├─ _populate_test_cases()
              ├─ BusinessReportGenerator.generate()
              ├─ _save_bug_report()
              └─ return FinalReport
```

### 8.2 自愈循环调用链

```
失败用例 (TestCaseResult)
    │
    ▼
_handle_failed_test()
    │
    ├─ ResultJudge.judge()
    │   │
    │   └─ 返回 JudgeResult
    │       ├─ need_healing: bool
    │       ├─ healing_type: SYNTAX | LOGIC
    │       └─ is_bug: bool
    │
    ├─ [需要自愈且 healing_type == SYNTAX]
    │   │
    │   └─ _heal_syntax()
    │       ├─ PromptBuilder.build_heal_syntax_prompt(error_info)
    │       │   └─ 包含: 错误类型、文件、行号、traceback
    │       │
    │       ├─ CLISession.send(prompt)
    │       │   └─ Claude 读取文件并修复代码
    │       │
    │       └─ 更新 result
    │           ├─ healing_attempts += 1
    │           └─ healed = True
    │
    └─ [需要自愈且 healing_type == LOGIC]
        │
        └─ _heal_logic()
            ├─ PromptBuilder.build_heal_logic_prompt(error_info, requirements)
            │   └─ 包含: 断言信息、期望值、实际值、业务规则
            │
            ├─ CLISession.send(prompt)
            │   └─ Claude 分析并判定
            │
            └─ _parse_logic_healing_result()
                │
                ├─ 判定为 Bug
                │   └─ _record_bug()
                │       └─ bugs.append(BugReport)
                │
                └─ 判定为脚本问题
                    └─ 更新 result
                        ├─ healing_attempts += 1
                        └─ healed = True
```

---

## 九、配置参数参考

### 9.1 WorkflowConfig

| 参数 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `max_healing_attempts` | int | 3 | 单个用例最大自愈次数 |
| `cli_timeout` | int | 1200 | CLI 调用超时（秒），20分钟 |
| `test_timeout` | int | 120 | 单个测试用例超时（秒） |
| `enable_exploration` | bool | False | 是否启用动态依赖探测 |
| `cancel_event` | Event | None | 取消信号 |
| `on_state_change` | Callable | None | 状态变更回调 |
| `on_log` | Callable | None | 日志回调 |
| `on_todo_update` | Callable | None | Todo 更新回调 |

### 9.2 CLIConfig

| 参数 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `timeout` | int | 1200 | CLI 超时（秒） |
| `working_dir` | str | None | 工作目录 |
| `allowed_tools` | List[str] | 见下文 | 允许的工具列表 |
| `output_format` | str | "stream-json" | 输出格式 |
| `max_retries` | int | 3 | 最大重试次数 |
| `retry_delay` | float | 2.0 | 重试延迟（秒） |
| `on_output` | Callable | None | 实时输出回调 |

**默认工具列表**：

```python
["Read", "Write", "Edit", "Bash", "Glob", "Grep"]
```

### 9.3 PytestConfig

| 参数 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `timeout` | int | 120 | 单个用例超时（秒） |
| `junit_xml` | str | "results.xml" | JUnit XML 文件名 |
| `html_report` | str | "report.html" | HTML 报告文件名 |
| `verbose` | bool | True | 详细输出 |
| `capture` | str | "no" | 输出捕获设置 |

---

## 十、扩展与集成

### 10.1 自定义 Prompt 模板

修改 `src/templates/` 下的模板文件：

- `plan_prompt.txt` - 调整用例设计规则
- `generate_prompt.txt` - 调整代码生成风格
- `heal_syntax_prompt.txt` - 调整语法自愈策略
- `heal_logic_prompt.txt` - 调整逻辑自愈判定规则

### 10.2 添加新的报告格式

继承或扩展 `BusinessReportGenerator`：

```python
from src.core.report_generator import BusinessReportGenerator

class CustomReportGenerator(BusinessReportGenerator):
    def generate(self, report: FinalReport, output_dir: str) -> str:
        # 自定义报告生成逻辑
        pass
```

### 10.3 集成到 CI/CD

```yaml
# GitHub Actions 示例
jobs:
  api-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: pip install -r requirements.txt

      - name: Run API Tests
        run: |
          python -m src.main \
            --swagger ./api/swagger.json \
            --base-url ${{ secrets.API_BASE_URL }} \
            --token ${{ secrets.API_TOKEN }} \
            --output ./test-results

      - name: Upload Results
        uses: actions/upload-artifact@v3
        with:
          name: test-results
          path: ./test-results/
```

---

## 十一、常见问题

### Q1: CLI 调用超时

**原因**：复杂的 Swagger 可能导致 Claude 分析时间过长

**解决**：
1. 增加 `cli_timeout` 参数
2. 拆分大型 Swagger 文件
3. 简化业务规则

### Q2: 自愈循环过多

**原因**：代码生成质量不稳定

**解决**：
1. 优化 Prompt 模板，添加更多示例
2. 减少 `max_healing_attempts`
3. 检查 Swagger 定义是否完整

### Q3: 测试用例 ID 未关联

**原因**：生成的代码缺少 `# TestCase: TC-XXX` 注释

**解决**：
1. 检查 `generate_prompt.txt` 是否包含注释要求
2. 确保 testcases.md 格式正确

---

## 十二、更新日志

| 版本 | 日期 | 更新内容 |
|------|------|----------|
| v1.0 | 2025-11-30 | 初始版本，支持四阶段工作流、双模式、自愈机制 |

---

*文档生成时间：2025-11-30*
